### 2.9.1. Instance Initialization Methods实例初始化方法
一个类有零个或多个实例初始化方法，每个方法通常对应于用Java编程语言编写的构造函数。

如果下列所有条件都为真，则该方法是实例初始化方法:

它是在类(而不是接口)中定义的。

它有一个特殊的名字<init>。

它是空的(§4.3.3)。

在类中，任何名为<init>的非void方法都不是实例初始化方法。在接口中，任何名为<init>的方法都不是实例初始化方法。这些方法不能被任何Java虚拟机指令调用(§4.4.2，§4.9.2)，并且会被格式检查拒绝(§4.6，§4.8)。

实例初始化方法的声明和使用受到Java虚拟机的约束。对于声明，方法的access_flags项和代码数组是受限的(§4.6，§4.9.2)。对于use，实例初始化方法只能由未初始化的类实例上的invokspecial指令调用(§4.10.1.9)。

因为名称<init>在Java编程语言中不是一个有效的标识符，所以不能在用Java编程语言编写的程序中直接使用它。
### 2.9.2.  Class Initialization Methods类初始化方法
一个类或接口最多有一个类或接口初始化方法，并由调用该方法的Java虚拟机初始化(§5.5)。

如果满足以下所有条件，则方法是类或接口初始化方法:

它有一个特殊的名称<clinit>。

它是空的(§4.3.3)。

在版本号为51.0或更高的类文件中，该方法设置了ACC_STATIC标志并且不接受参数(第4.6节)。

在Java SE 7中引入了对ACC_STATIC的要求，在Java SE 9中引入了不接受参数的要求。在版本号为50.0或以下的类文件中，名为<clinit>的方法如果为void，则被认为是类或接口初始化方法，而不管其ACC_STATIC标志的设置或是否接受参数。

类文件中名为<clinit>的其他方法不是类或接口初始化方法。它们永远不会被Java虚拟机本身调用，不能被任何Java虚拟机指令调用(第4.9.1节)，并且会被格式检查拒绝(第4.6节，第4.8节)。

因为名称<clinit>在Java编程语言中不是一个有效的标识符，所以不能在用Java编程语言编写的程序中直接使用它。

### 2.9.3. Signature Polymorphic Methods签名多态方法
如果满足以下所有条件，则该方法是签名多态的:

它在java.lang.invoke.MethodHandle类或java.lang.invoke.VarHandle类中声明。

它有一个Object[]类型的形式参数。

它设置了ACC_VARARGS和ACC_NATIVE标志。

Java虚拟机在invokvirtual指令(§invokvirtual)中对签名多态方法进行了特殊处理，以便对方法句柄进行调用或对Java .lang.invoke. varhandle实例引用的变量进行访问。

方法句柄是对底层方法、构造函数、字段或类似的低级操作(§5.4.3.5)的动态强类型和直接可执行的引用，具有参数或返回值的可选转换。varhandle的实例是对变量或变量族的动态强类型引用，包括静态字段、非静态字段、数组元素或堆外数据结构的组件。有关更多信息，请参阅Java SE平台API中的Java .lang.invoke包