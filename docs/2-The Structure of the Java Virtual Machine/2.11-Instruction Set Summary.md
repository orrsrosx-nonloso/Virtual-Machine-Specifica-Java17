Java虚拟机指令由一个指定要执行的操作的一字节操作码组成，后面跟着零个或多个操作数，提供操作使用的参数或数据。许多指令没有操作数，只由一个操作码组成。

忽略异常，Java虚拟机解释器的内部循环是有效的

`java`

```
do {
    atomically calculate pc and fetch opcode at pc;
    if (operands) fetch operands;
    execute the action for the opcode;
} while (there is more to do);
```

操作数的数量和大小由操作码决定。如果操作数的大小大于一个字节，则按大端顺序存储——高序字节优先。例如，到局部变量的无符号16位索引被存储为两个无符号字节，byte1和byte2，因此其值为(byte1 << 8) | byte2。

字节码指令流只是单字节对齐。两个例外是lookupswitch和tableswitch指令(§lookupswitch，§tableswitch)，它们被填充以强制在4字节边界上对某些操作数进行内部对齐。

将Java虚拟机操作码限制为一个字节并放弃编译代码中的数据对齐的决定反映了对紧凑性的有意识偏好，这可能以在幼稚实现中牺牲一些性能为代价。一个字节的操作码也限制了指令集的大小。不假设数据对齐意味着必须在许多机器的运行时从字节构造大于一个字节的即时数据。

### 2.11.1. Types and the Java Virtual Machine类型和Java虚拟机
Java虚拟机指令集中的大多数指令都对它们执行的操作的类型信息进行编码。例如，加载指令(§ilload)将局部变量的内容加载到操作数堆栈中，该局部变量必须是int型。load指令(§load)对浮点值做同样的操作。这两个指令可能具有相同的实现，但具有不同的操作码。

对于大多数类型指令，指令类型在操作码助记符中用字母显式表示:i表示int操作，l表示long操作，s表示short操作，b表示byte操作，c表示char操作，f表示float操作，d表示double操作，a表示reference操作。某些类型明确的指令在助记符中没有类型字母。例如，arraylength总是对数组对象进行操作。一些指令，如goto，一个无条件的控制转移，不操作类型化的操作数。

由于Java虚拟机的操作码大小为1字节，因此将类型编码为操作码会给其指令集的设计带来压力。如果每个类型化指令都支持所有Java虚拟机的运行时数据类型，那么指令的数量将超过一个字节所能表示的数量。相反，Java虚拟机的指令集为某些操作提供了较低级别的类型支持。换句话说，指令集故意不是正交的。根据需要，可以使用单独的指令在不支持和支持的数据类型之间进行转换。

表2.11.1-A总结了Java虚拟机指令集中的类型支持。通过将指令模板中的操作码列中的T替换为类型列中的字母，构建具有类型信息的特定指令。如果某些指令模板和类型的type列为空，则不存在支持该操作类型的指令。例如，有一个int类型的加载指令ilload，但是没有一个byte类型的加载指令。

注意，表2.11.1-A中的大多数指令都没有整型byte、char和short的形式。它们都没有布尔类型的表单。编译器使用Java虚拟机指令对字节和短类型的文字值进行编码，这些指令在编译时或运行时将这些值符号扩展为int类型的值。布尔类型和char类型的文字值的加载是使用在编译时或运行时将文字零扩展为int类型的指令进行编码的。同样地，从布尔类型、字节类型、短类型和char类型的值的数组中加载的数据也使用Java Virtual Machine指令进行编码，这些指令将值进行符号扩展或零扩展，以转换为int类型的值。因此，对布尔型、字节型、char型和short型实际类型的值的大多数操作，都可以由对计算型int型值进行操作的指令正确执行。

Table 2.11.1-A. Type support in the Java Virtual Machine instruction set 在Java虚拟机指令集中键入支持
![Alt text](image.png)
Java虚拟机实际类型与Java虚拟机计算类型的对应关系如表2.11.1-B所示。

某些Java虚拟机指令，如pop和swap，在操作数堆栈上操作而不考虑类型;然而，这些指令被限制只能用于计算类型的某些类别的值，如表2.11.1-B所示。

表2.11.1-B.Java虚拟机中的实际类型和计算类型

![Alt text](image-1.png)