## 2.6
帧用于存储数据和部分结果，以及执行动态链接、为方法返回值和分派异常。

每次调用方法时都会创建一个新框架。当一个框架的方法调用完成时，无论该完成是正常的还是突然的(都会抛出未捕获的异常)，该框架都会被销毁。帧是从创建帧的线程的Java虚拟机堆栈(§2.5.2)中分配的。每个帧都有自己的局部变量数组(第2.6.1节)，自己的操作数堆栈(第2.6.2节)，以及对当前方法类的运行时常量池(第2.5.5节)的引用。

一个帧可以用附加的特定于实现的信息(如调试信息)进行扩展。

局部变量数组和操作数堆栈的大小在编译时确定，并与与帧相关的方法的代码一起提供(第4.7.3节)。因此，帧数据结构的大小仅取决于Java虚拟机的实现，这些结构的内存可以在方法调用时同时分配。

在给定的控制线程中，只有一个帧(用于执行方法的帧)是活动的。这个框架被称为当前框架，它的方法被称为当前方法。定义当前方法的类就是当前类。对局部变量和操作数堆栈的操作通常引用当前帧。

如果一个框架的方法调用了另一个方法或者它的方法完成了，那么这个框架就不再是当前的。当调用一个方法时，将创建一个新框架，并在控制转移到新方法时成为当前框架。在方法返回时，当前帧将其方法调用的结果(如果有的话)传递给前一帧。当前一帧变成当前帧时，当前帧被丢弃。

请注意，由线程创建的帧是该线程的本地帧，不能被任何其他线程引用。

### 2.6.1
每个帧(§2.6)包含一个变量数组，称为局部变量。帧的局部变量数组的长度在编译时确定，并在类或接口的二进制表示中提供，以及与帧相关的方法的代码(第4.7.3节)。

单个局部变量可以保存布尔型、字节型、char型、short型、int型、float型、reference型或returnAddress型的值。一对局部变量可以保存long或double类型的值。

局部变量通过索引来寻址。第一个局部变量的索引为零。当且仅当该整数小于局部变量数组的大小在0到1之间时，才认为该整数是局部变量数组的索引。

long类型或double类型的值占用两个连续的局部变量。这样的值只能使用较小的索引来寻址。例如，存储在索引为n的局部变量数组中的double类型的值实际上占用了索引为n和n+1的局部变量;但是，不能从索引n+1处加载局部变量。它可以存储到。但是，这样做会使局部变量n的内容无效。

Java虚拟机不要求n为偶数。直观地说，在局部变量数组中，long和double类型的值不需要64位对齐。实现者可以自由决定使用为值保留的两个局部变量来表示这些值的适当方式。

Java虚拟机使用局部变量在方法调用时传递参数。在类方法调用时，任何参数都在从局部变量0开始的连续局部变量中传递。在实例方法调用时，总是使用局部变量0向调用实例方法的对象传递引用(在Java编程语言中是这样)。任何参数随后都在从局部变量1开始的连续局部变量中传递。

### 2.6.2. Operand Stacks
每个帧(§2.6)包含一个后进先出(LIFO)堆栈，称为操作数堆栈。一个帧的操作数栈的最大深度是在编译时确定的，并与与该帧相关的方法的代码一起提供(第4.7.3节)。

在上下文明确的情况下，我们有时将当前帧的操作数堆栈简单地称为操作数堆栈。

当包含它的帧被创建时，操作数堆栈为空。Java虚拟机提供了将常量或值从局部变量或字段加载到操作数堆栈的指令。其他Java虚拟机指令从操作数堆栈中获取操作数，对其进行操作，然后将结果压回操作数堆栈。操作数堆栈还用于准备传递给方法的参数和接收方法结果。

例如，iadd指令(§iadd)将两个int值相加。它要求要添加的int值是操作数堆栈的前两个值，由前面的指令推送到那里。这两个int值都是从操作数堆栈中弹出的。它们被相加，它们的和被压回操作数堆栈。子计算可以嵌套在操作数堆栈上，从而产生可供包含计算使用的值。

操作数堆栈上的每个条目都可以保存任何Java虚拟机类型的值，包括long类型或double类型的值。

操作数堆栈中的值必须以适合其类型的方式进行操作。例如，不可能将两个int值压入并随后将其视为长值，也不可能将两个float值压入并随后使用iadd指令将其相加。少数Java虚拟机指令(dup指令(§dup)和swap指令(§swap))作为原始值对运行时数据区域进行操作，而不考虑它们的特定类型;这些指令的定义方式使它们不能用于修改或分解单个值。这些对操作数堆栈操作的限制是通过类文件验证来实施的(§4.10)。

在任何时间点，操作数堆栈都有一个关联的深度，其中long或double类型的值为深度贡献两个单位，其他类型的值贡献一个单位。


### 2.6.3. Dynamic Linking
每个帧(§2.6)都包含一个对当前方法类型的运行时常量池(§2.5.5)的引用，以支持方法代码的动态链接。方法的类文件代码引用要调用的方法和通过符号引用访问的变量。动态链接将这些符号方法引用转换为具体的方法引用，根据需要加载类以解析尚未定义的符号，并将变量访问转换为与这些变量的运行时位置相关的存储结构中的适当偏移量。

方法和变量的这种后期绑定使得方法使用的其他类中的更改不太可能破坏此代码。

### 2.6.4. Normal Method Invocation Completion
如果调用没有导致异常(§2.10)被抛出，则方法调用正常完成，无论是直接从Java虚拟机还是作为执行显式抛出语句的结果。如果当前方法的调用正常完成，则可以向调用方法返回一个值。当被调用的方法执行其中一条返回指令(§2.11.8)时，就会发生这种情况，其中的选择必须适合被返回值的类型(如果有的话)。

在这种情况下，当前帧(§2.6)用于恢复调用程序的状态，包括其局部变量和操作数堆栈，调用程序的程序计数器适当地增加以跳过方法调用指令。然后在调用方法的框架中继续正常执行，返回值(如果有的话)被压入该框架的操作数堆栈。
### 2.6.5. Abrupt Method Invocation Completion
如果在方法内执行Java虚拟机指令导致Java虚拟机抛出异常(§2.10)，并且该异常未在方法内处理，则方法调用会突然完成。执行throw指令(§throw)也会导致显式抛出异常，如果当前方法没有捕获异常，则会导致方法调用突然完成。突然完成的方法调用永远不会向其调用者返回值。
