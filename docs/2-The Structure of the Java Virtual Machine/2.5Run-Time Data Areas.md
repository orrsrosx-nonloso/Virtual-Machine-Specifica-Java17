## 2.5. Run-Time Data Areas
Java虚拟机定义了在程序执行期间使用的各种运行时数据区域。其中一些数据区域是在Java虚拟机启动时创建的，只有在Java虚拟机退出时才会销毁。其他数据区域是按线程划分的。每个线程的数据区域在创建线程时创建，在线程退出时销毁。

### 2.5.1. The pc Register
Java虚拟机可以支持多个线程同时执行(JLS§17)。每个Java虚拟机线程都有自己的pc(程序计数器)寄存器。在任何时候，每个Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法(§2.6)。如果该方法不是本机的，则pc寄存器包含当前正在执行的Java虚拟机指令的地址。如果线程当前正在执行的方法是本机的，则Java虚拟机的pc寄存器的值是未定义的。Java虚拟机的pc寄存器足够宽，可以保存特定平台上的returnAddress或本机指针。

### 2.5.2 Java Virtual Machine Stacks

每个Java虚拟机线程都有一个私有的Java虚拟机堆栈，与线程同时创建。Java虚拟机堆栈存储帧(第2.6节)。Java虚拟机堆栈类似于传统语言(如C语言)的堆栈:它保存局部变量和部分结果，并在方法调用和返回中起作用。因为Java虚拟机堆栈从来不被直接操作，除了推送和弹出帧之外，帧可以被堆分配。Java虚拟机堆栈的内存不需要是连续的。

在Java®虚拟机规范的第一版中，Java虚拟机堆栈被称为Java堆栈。

该规范允许Java虚拟机堆栈具有固定大小或根据计算需要动态扩展和收缩。如果Java虚拟机堆栈的大小是固定的，那么每个Java虚拟机堆栈的大小可以在创建堆栈时独立选择。

Java虚拟机实现可以为程序员或用户提供对Java虚拟机堆栈的初始大小的控制，以及在动态扩展或收缩Java虚拟机堆栈的情况下，对最大和最小大小的控制。

以下异常情况与Java虚拟机堆栈相关:

如果线程中的计算需要比允许的更大的Java虚拟机堆栈，则Java虚拟机抛出StackOverflowError。

如果Java虚拟机堆栈可以动态扩展，并且尝试扩展，但是没有足够的内存可用来影响扩展，或者如果没有足够的内存可用来为新线程创建初始Java虚拟机堆栈，则Java虚拟机抛出OutOfMemoryError。