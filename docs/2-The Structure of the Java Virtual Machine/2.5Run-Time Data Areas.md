## 2.5. 运行时数据区Run-Time Data Areas
Java虚拟机定义了在程序执行期间使用的各种运行时数据区域。其中一些数据区域是在Java虚拟机启动时创建的，只有在Java虚拟机退出时才会销毁。其他数据区域是按线程划分的。每个线程的数据区域在创建线程时创建，在线程退出时销毁。

### 2.5.1. 个人电脑登记册The pc Register
Java虚拟机可以支持多个线程同时执行(JLS§17)。每个Java虚拟机线程都有自己的pc(程序计数器)寄存器。在任何时候，每个Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法(§2.6)。如果该方法不是本机的，则pc寄存器包含当前正在执行的Java虚拟机指令的地址。如果线程当前正在执行的方法是本机的，则Java虚拟机的pc寄存器的值是未定义的。Java虚拟机的pc寄存器足够宽，可以保存特定平台上的returnAddress或本机指针。

### 2.5.2 Java虚拟机栈Java Virtual Machine Stacks

每个Java虚拟机线程都有一个私有的Java虚拟机堆栈，与线程同时创建。Java虚拟机堆栈存储帧(第2.6节)。Java虚拟机堆栈类似于传统语言(如C语言)的堆栈:它保存局部变量和部分结果，并在方法调用和返回中起作用。因为Java虚拟机堆栈从来不被直接操作，除了推送和弹出帧之外，帧可以被堆分配。Java虚拟机堆栈的内存不需要是连续的。

在Java®虚拟机规范的第一版中，Java虚拟机堆栈被称为Java堆栈。

该规范允许Java虚拟机堆栈具有固定大小或根据计算需要动态扩展和收缩。如果Java虚拟机堆栈的大小是固定的，那么每个Java虚拟机堆栈的大小可以在创建堆栈时独立选择。

Java虚拟机实现可以为程序员或用户提供对Java虚拟机堆栈的初始大小的控制，以及在动态扩展或收缩Java虚拟机堆栈的情况下，对最大和最小大小的控制。

以下异常情况与Java虚拟机堆栈相关:

如果线程中的计算需要比允许的更大的Java虚拟机堆栈，则Java虚拟机抛出StackOverflowError。

如果Java虚拟机堆栈可以动态扩展，并且尝试扩展，但是没有足够的内存可用来影响扩展，或者如果没有足够的内存可用来为新线程创建初始Java虚拟机堆栈，则Java虚拟机抛出OutOfMemoryError。

### 2.5.3 Heap


所有者Java虚拟机有一个堆，它在所有Java虚拟机线程之间共享。堆是为所有类实例和数组分配内存的运 行时数据区域。

堆在虚拟机启动时创建。对象的堆存储由自动存储管理系统(称为垃圾收集器)回收;对象永远不会显式释放。Java虚拟机没有特定类型的自动存储管理系统，存储管理技术可以根据实现者的系统需求来选择。堆的大小可以是固定的，也可以根据计算的需要进行扩展，如果不需要更大的堆，则可以收缩堆。堆的内存不需要是连续的。

Java虚拟机实现可以让程序员或用户控制堆的初始大小，如果堆可以动态扩展或收缩，还可以控制堆的最大和最小大小。

以下异常条件与堆相关: 如果计算需要的堆超过自动存储管理系统所能提供的堆，则Java虚拟机抛出OutOfMemoryError。

### 2.5.4 Method Area
Java虚拟机有一个在所有Java虚拟机线程之间共享的方法区域。方法区域类似于传统语言编译代码的存储区域或类似于操作系统进程中的“文本”段。它存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和接口初始化以及实例初始化中使用的特殊方法(§2.9)。

方法区域在虚拟机启动时创建。虽然方法区域在逻辑上是堆的一部分，但简单的实现可能选择不进行垃圾收集或压缩它。该规范不强制要求方法区域的位置或用于管理编译代码的策略。方法区域可以是固定大小的，也可以根据计算的需要扩展，如果不需要更大的方法区域，也可以收缩。方法区域的内存不必是连续的。

Java虚拟机实现可以为程序员或用户提供对方法区域初始大小的控制，以及，在变化大小的方法区域的情况下，对最大和最小方法区域大小的控制。

以下异常情况与方法区域相关:

如果方法区域中的内存不能用于满足分配请求，则Java虚拟机抛出OutOfMemoryError。

### 2.5.5. Run-Time Constant Pool

运行时常数池是类文件中constant_pool表的按类或按接口的运行时表示(§4.4)。它包含几种常量，从编译时已知的数值字面量到必须在运行时解析的方法和字段引用。运行时常数池的功能类似于传统编程语言的符号表，尽管它比典型的符号表包含更广泛的数据。

每个运行时常数池都是从Java虚拟机的方法区分配的(§2.5.4)。类或接口的运行时常数池是在Java虚拟机创建类或接口时构造的(第5.3节)。

下列异常条件与类或接口的运行时常数池的构造有关:

在创建类或接口时，如果运行时常数池的构造需要比Java虚拟机的方法区可用的内存更多的内存，Java虚拟机将抛出OutOfMemoryError。

参见§5(加载、链接和初始化)，了解运行时常数池的构造。

### 2.5.6. Native Method Stacks
Java虚拟机的实现可以使用传统的堆栈(通俗地称为“C堆栈”)来支持本机方法(用Java编程语言以外的语言编写的方法)。本机方法栈也可以由Java虚拟机指令集的解释器实现(如c语言)使用，Java虚拟机实现不能加载本机方法，并且本身不依赖于传统堆栈，不需要提供本机方法栈。如果提供了本机方法堆栈，则通常在创建每个线程时为每个线程分配。

此规范允许本机方法堆栈具有固定大小或根据计算需要动态扩展和收缩。如果本机方法堆栈的大小是固定的，则可以在创建堆栈时独立选择每个本机方法堆栈的大小。

Java虚拟机实现可以为程序员或用户提供对本机方法堆栈初始大小的控制，以及在不同大小的本机方法堆栈的情况下，对最大和最小方法堆栈大小的控制。

以下异常情况与本机方法堆栈相关:

如果线程中的计算需要比允许的更大的本机方法堆栈，则Java虚拟机抛出StackOverflowError。

如果本机方法堆栈可以动态扩展，并且尝试进行本机方法堆栈扩展，但是可用的内存不足，或者可用的内存不足以为新线程创建初始本机方法堆栈，则Java虚拟机抛出OutOfMemoryError。